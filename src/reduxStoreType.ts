import { ReducerType } from "./reducerCreator";

/**
 * Get the type of the root reducer which is generated by `Redux` API `combineReducers()`
 */
export type RootReducerType<T extends ReducerType = ReducerType> = ReturnType<
  T
>;

/**
 * The interface of AsyncReducers
 */
export interface IAsyncReducers {
  [key: string]: ReducerType;
}

export type PartialAsyncReducers<T extends IAsyncReducers> = Partial<T>;
export type AsyncReducersKeyType<T extends IAsyncReducers> = keyof T;
export type AsyncReducersValueType<
  T extends IAsyncReducers
> = T[AsyncReducersKeyType<T>];

/**
 * Get the type of async reducer,which you could inject reducer lazily.
 * Use `Redux` API `combineReducers()` to combine the root reducer and async reducer
 * as one reducer, then use `Redux` API `replaceReducer()` to refresh it.
 */
export type AsyncReducerType<T extends IAsyncReducers> = {
  [K in AsyncReducersKeyType<T>]: ReturnType<T[K]>;
};

/**
 * Get the whole redux store type, if you have async reducer, be sure the reducer
 * has been injected when you call it.
 */
export type StoreStateType<
  R extends RootReducerType = {},
  A extends IAsyncReducers = {}
> = {
  [K in keyof R | keyof AsyncReducerType<A>]: (R & AsyncReducerType<A>)[K];
};
