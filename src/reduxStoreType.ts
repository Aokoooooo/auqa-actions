import { ReducerType } from "./reducerCreator";

/**
 * The type of the root reducer which is generated by `Redux` API `combineReducers()`.
 * If you have some reducer which are injected lazily, don't put them in.It's better to
 * use `AsyncReducerType`
 */
export type RootReducerType<T extends ReducerType = ReducerType> = ReturnType<
  T
>;

/**
 * The type of AsyncReducer
 */
// tslint:disable-next-line: interface-over-type-literal
export type AsyncReducers = {
  [key: string]: ReducerType;
};

export type PartialAsyncReducers<T extends AsyncReducers> = Partial<T>;
export type AsyncReducersKeyType<T extends AsyncReducers> = keyof T;
export type AsyncReducersValueType<
  T extends AsyncReducers
> = T[AsyncReducersKeyType<T>];

/**
 * The type of async reducer,which you could inject reducer lazily.
 * Use `Redux` API `combineReducers()` to combine the root reducer and async reducer
 * as one reducer, then use `Redux` API `replaceReducer()` to refresh it.
 */
export type AsyncReducerType<T extends AsyncReducers> = {
  [K in AsyncReducersKeyType<T>]: ReturnType<T[K]>;
};

/**
 * The whole redux store type, if you have async reducer, be sure the reducer
 * has been injected when you call it.
 */
export type StoreStateType<
  R extends RootReducerType = {},
  A extends AsyncReducers = {}
> = {
  [K in keyof R | keyof AsyncReducerType<A>]: (R & AsyncReducerType<A>)[K];
};
